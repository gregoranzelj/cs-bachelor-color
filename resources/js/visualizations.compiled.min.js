(function e(b,g,d){function c(m,j){if(!g[m]){if(!b[m]){var i=typeof require=="function"&&require;if(!j&&i){return i(m,!0)}if(a){return a(m,!0)}var k=new Error("Cannot find module '"+m+"'");throw k.code="MODULE_NOT_FOUND",k}var h=g[m]={exports:{}};b[m][0].call(h.exports,function(l){var o=b[m][1][l];return c(o?o:l)},h,h.exports,e,b,g,d)}return g[m].exports}var a=typeof require=="function"&&require;for(var f=0;f<d.length;f++){c(d[f])}return c})({1:[function(c,b,g){var d=function(){function n(r,p){for(var o=0;o<p.length;o++){var q=p[o];q.enumerable=q.enumerable||false;q.configurable=true;if("value" in q){q.writable=true}Object.defineProperty(r,q.key,q)}}return function(q,o,p){if(o){n(q.prototype,o)}if(p){n(q,p)}return q}}();function k(n,o){if(!n){throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}return o&&(typeof o==="object"||typeof o==="function")?o:n}function l(o,n){if(typeof n!=="function"&&n!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof n)}o.prototype=Object.create(n&&n.prototype,{constructor:{value:o,enumerable:false,writable:true,configurable:true}});if(n){Object.setPrototypeOf?Object.setPrototypeOf(o,n):o.__proto__=n}}function h(n,o){if(!(n instanceof o)){throw new TypeError("Cannot call a class as a function")}}var f=c("../shaders/default-vertex.glsl");var i=function(){function t(B){h(this,t);this.$container=B;this.fov=45;this.min_focal_length=10;this.max_focal_length=400;this.zoom_steps=20;this.zoom_sensitivity=0.25;this.aspect=B.width()/B.height();this.near=0.1;this.far=10000;this.renderer=new THREE.WebGLRenderer({antialias:true});this.scene=new THREE.Scene();this.axis_helper=new THREE.AxisHelper(5);this.pivot=new THREE.Object3D();this.camera=new THREE.PerspectiveCamera(this.fov,this.aspect,this.near,this.far);this.camera.position.set(0,0,0,1);this.camera.applyMatrix(new THREE.Matrix4().makeTranslation(0,0,3));this.camera.lookAt(this.scene.position);this.pivot.add(this.camera);this.scene.add(this.pivot);this.scene.add(this.axis_helper);this.renderer.setClearColor(5263440,1);this.renderer.setSize(this.$container.width(),this.$container.height());this.$container.append(this.renderer.domElement);var A=this;$(window).resize(function(){A.on_resize.call(A)});this.current_rotation=new THREE.Euler(0,0,0,"YXZ");this.starting_rotation=new THREE.Euler(0,0,0,"YXZ");this.starting_focal_length=0;this.dragging=false;this.two_fingers_touching=false;this.drag_start=new THREE.Vector2(0,0);this.scale_start_distance=0;this.$container.mousedown(function(C){A.on_mouse_down.call(A,C)});this.$container.on("wheel",function(C){A.on_wheel.call(A,C)});this.mouse_move_handler=function(C){A.on_mouse_move.call(A,C)};this.mouse_up_handler=function(C){A.on_mouse_up.call(A,C)};this.$container.on("touchstart",function(C){A.on_touch_start.call(A,C)});this.$container.on("touchmove",function(C){A.on_touch_move.call(A,C)});this.$container.on("touchcancel",function(C){A.on_touch_cancel.call(A,C)});this.$container.on("touchend",function(C){A.on_touch_end.call(A,C)})}d(t,[{key:"render",value:function n(){this.renderer.render(this.scene,this.camera)}},{key:"update_rotation",value:function x(B,A){this.current_rotation.y=(this.starting_rotation.y+A)%(2*Math.PI);this.current_rotation.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,(this.starting_rotation.x+B)%(2*Math.PI)));this.pivot.rotation.copy(this.current_rotation)}},{key:"update_scale",value:function v(A){this.camera.setFocalLength(Math.max(this.min_focal_length,Math.min(this.max_focal_length,this.starting_focal_length+A)))}},{key:"on_resize",value:function y(){this.renderer.setSize(this.$container.width(),this.$container.height());this.camera.aspect=this.$container.width()/this.$container.height();this.camera.updateProjectionMatrix();this.render()}},{key:"on_mouse_down",value:function r(B){this.drag_start.set(B.pageX,B.pageY);this.starting_rotation.copy(this.pivot.rotation);this.dragging=true;var A=this;document.addEventListener("mousemove",this.mouse_move_handler,false);document.addEventListener("mouseup",this.mouse_up_handler,false)}},{key:"on_mouse_move",value:function w(A){if(!this.dragging){return}A.preventDefault();var B=-(A.pageX-this.drag_start.x)/$(window).width()*2*Math.PI;var C=-(A.pageY-this.drag_start.y)/$(window).height()*2*Math.PI;this.update_rotation(C,B);this.render()}},{key:"on_mouse_up",value:function u(A){this.dragging=false;document.removeEventListener("mousemove",this.mouse_move_handler,false);document.removeEventListener("mouseup",this.mouse_up_handler,false)}},{key:"on_wheel",value:function q(A){var B=-A.originalEvent.deltaY;A.preventDefault();switch(A.originalEvent.deltaMode){case 0:B*=(this.max_focal_length-this.min_focal_length)/$(window).height();break;case 1:case 2:B*=(this.max_focal_length-this.min_focal_length)/this.zoom_steps;break}this.starting_focal_length=this.camera.getFocalLength();this.update_scale(B*this.zoom_sensitivity);this.render()}},{key:"on_touch_start",value:function s(A){this.drag_start.set(A.touches[0].pageX,A.touches[0].pageY);this.starting_rotation.copy(this.pivot.rotation);this.dragging=true;switch(A.touches.length){case 1:break;case 2:A.preventDefault();this.scale_start_distance=new THREE.Vector2(A.touches[0].pageX,A.touches[0].pageY).distanceTo(new THREE.Vector2(A.touches[1].pageX,A.touches[1].pageY));this.starting_focal_length=this.camera.getFocalLength();this.two_fingers_touching=true;break}document.addEventListener("mousemove",this.mouse_move_handler,false);document.addEventListener("mouseup",this.mouse_up_handler,false)}},{key:"on_touch_move",value:function z(A){if(!this.dragging){return}var B=-(A.touches[0].pageX-this.drag_start.x)/$(window).width()*2*Math.PI;var E=-(A.touches[0].pageY-this.drag_start.y)/$(window).height()*2*Math.PI;if(!this.two_fingers_touching){E=0}this.update_rotation(E,B);if(this.two_fingers_touching){A.preventDefault();var D=new THREE.Vector2(A.touches[0].pageX,A.touches[0].pageY).distanceTo(new THREE.Vector2(A.touches[1].pageX,A.touches[1].pageY));var C=(D-this.scale_start_distance)/$(window).width()*(this.max_focal_length-this.min_focal_length);this.update_scale(C)}this.render()}},{key:"on_touch_cancel",value:function p(A){}},{key:"on_touch_end",value:function o(A){this.on_mouse_up(A);this.two_fingers_touching=false}}]);return t}();var a=function(o){l(n,o);function n(p){h(this,n);var q=k(this,(n.__proto__||Object.getPrototypeOf(n)).call(this,p));q.wireframe_cube_geometry=new THREE.BoxGeometry(1,1,1);q.wireframe_cube=new THREE.BoxHelper(new THREE.Mesh(q.wireframe_cube_geometry),0);q.wireframe_cube.applyMatrix(new THREE.Matrix4().makeTranslation(0.5,0.5,0.5));q.scene.add(q.wireframe_cube);q.rgb_cube_geometry=new THREE.BoxGeometry(1,1,1);q.rgb_cube_shader=c("../shaders/rgb-fragment.glsl");q.rgb_cube_mat=new THREE.ShaderMaterial({vertexShader:f(),fragmentShader:q.rgb_cube_shader()});q.rgb_cube_mesh=new THREE.Mesh(q.rgb_cube_geometry,q.rgb_cube_mat);q.rgb_cube_mesh.applyMatrix(new THREE.Matrix4().makeTranslation(0.5,0.5,0.5));q.scene.add(q.rgb_cube_mesh);q.pivot.applyMatrix(new THREE.Matrix4().makeTranslation(0.5,0.5,0.5));return q}return n}(i);var m=[];var j={};$(document).ready(function(){console.log("Initializing visualizations.");$(".visualization.rgb-cube").each(function(){var n=new a($(this));n.render();m.push(n)});$(".figure-title").each(function(n){var o=$(this).parent().attr("id");j[o]=n+1;$(this).prepend("<b>Figure "+(n+1).toString()+":</b> ")});$("figref").each(function(){var n=$(this).data("fig-id");$(this).html('<a href="#'+n+'">Figure '+j[n]+"</a>")})})},{"../shaders/default-vertex.glsl":2,"../shaders/rgb-fragment.glsl":3}],2:[function(b,c,a){c.exports=function d(i){var g="/* \n * Predefined built-in uniforms and attributes for vertex shader: \n * http://threejs.org/docs/api/renderers/webgl/WebGLProgram.html \n \n * // = object.matrixWorld \n * uniform mat4 modelMatrix; \n \n * // = camera.matrixWorldInverse * object.matrixWorld \n * uniform mat4 modelViewMatrix; \n \n * // = camera.projectionMatrix \n * uniform mat4 projectionMatrix; \n \n * // = camera.matrixWorldInverse \n * uniform mat4 viewMatrix; \n \n * // = inverse transpose of modelViewMatrix \n * uniform mat3 normalMatrix; \n \n * // = camera position in world space \n * uniform vec3 cameraPosition; \n * \n * Additionally from GLSL: \n * https://www.opengl.org/wiki/Built-in_Variable_(GLSL) \n * gl_FragCoord \n */ \n \n/* \n  Fragment position in world space. \n  Thanks to \n  https://www.opengl.org/discussion_boards/showthread.php/163272-How-do-I-get-a-fragments-x-y-z-in-world-coordinates-in-the-fragment-shader \n  and \n  https://en.wikibooks.org/wiki/GLSL_Programming/Unity/Shading_in_World_Space \n*/ \nvarying vec4 worldCoord; \n \n/** \n * Multiply each vertex by the \n * model-view matrix and the \n * projection matrix (both provided \n * by Three.js) to get a final \n * vertex position. \n * (Copied from https://aerotwist.com/tutorials/an-introduction-to-shaders-part-1/) \n */ \nvoid main() { \n  worldCoord = modelMatrix * vec4(position,1.0); \n \n  gl_Position = projectionMatrix * \n                modelViewMatrix * \n                vec4(position,1.0); \n} \n";i=i||{};for(var f in i){var h=new RegExp("{{"+f+"}}","g");g=g.replace(h,i[f])}return g}},{}],3:[function(b,c,a){c.exports=function d(i){var g="varying vec4 worldCoord; \n \nvoid main() { \n    /* worldPos = ModelView^(-1) * Projection^(-1) * p */ \n    /*mat4 normalMatrix4 = mat4(varNormalMatrix); \n    normalMatrix4[3][3] = 1.0; \n    vec4 worldPositionTmp = normalMatrix4 * gl_FragCoord; \n    vec4 worldPosition = vec4( \n        worldPositionTmp.x, \n        worldPositionTmp.y, \n        worldPositionTmp.z, \n        worldPositionTmp.z / gl_FragCoord.w // undo perspective projection matrix \n    );*/ \n    gl_FragColor = vec4(worldCoord.x, \n                        worldCoord.y, \n                        worldCoord.z, \n                        1.0); \n} \n \n";i=i||{};for(var f in i){var h=new RegExp("{{"+f+"}}","g");g=g.replace(h,i[f])}return g}},{}]},{},[1]);